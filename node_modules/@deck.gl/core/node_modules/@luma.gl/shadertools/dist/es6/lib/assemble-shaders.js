import { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';
import { resolveModules, getShaderModule } from './resolve-modules';
import { getPlatformShaderDefines, getVersionDefines } from './platform-defines';
import injectShader from './inject-shader';
import { assert } from '../utils';
const SHADER_TYPE = {
  [VERTEX_SHADER]: 'vertex',
  [FRAGMENT_SHADER]: 'fragment'
};
const HOOK_FUNCTIONS = {
  [VERTEX_SHADER]: {},
  [FRAGMENT_SHADER]: {}
};
const MODULE_INJECTIONS = {};
const FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
export function createShaderHook(hook) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  hook = hook.trim();
  const [stage, signature] = hook.split(':');
  const name = hook.replace(/\(.+/, '');
  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {
    signature
  });
}
export function createModuleInjection(moduleName, opts) {
  const {
    hook,
    injection,
    order = 0
  } = opts;
  const shaderStage = hook.slice(0, 2);
  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};
  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};
  assert(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');
  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {
    injection,
    order
  };
}
export function assembleShaders(gl) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    vs,
    fs
  } = opts;
  const modules = resolveModules(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules),
    modules: assembleModuleMap(modules)
  };
}

function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules = [],
    defines = {},
    inject = {},
    prologue = true,
    log
  } = _ref;
  assert(typeof source === 'string', 'shader source must be a string');
  const isVertex = type === VERTEX_SHADER;
  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;

  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  }

  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  let injectStandardStubs = false;
  const hookInjections = {};
  const mainInjections = {};

  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];

    if (key.match(/^(v|f)s:/)) {
      if (key[3] === '#') {
        mainInjections[key] = [injection];
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }

  for (const module of modules) {
    switch (module.name) {
      case 'inject':
        injectStandardStubs = true;
        break;

      default:
        module.checkDeprecations(coreSource, log);
        const moduleSource = module.getModuleSource(type, glslVersion);
        assembledSource += moduleSource;

        if (MODULE_INJECTIONS[module.name]) {
          const injections = MODULE_INJECTIONS[module.name][type];

          for (const key in injections) {
            if (key.match(/^(v|f)s:#/)) {
              mainInjections[key] = mainInjections[key] || [];
              mainInjections[key].push(injections[key]);
            } else {
              hookInjections[key] = hookInjections[key] || [];
              hookInjections[key].push(injections[key]);
            }
          }
        }

    }
  }

  assembledSource += getHookFunctions(type, hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);
  return assembledSource;
}

function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};

    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }

    return uniforms;
  };
}

function assembleModuleMap(modules) {
  const result = {};

  for (const moduleName of modules) {
    const shaderModule = getShaderModule(moduleName);
    result[moduleName] = shaderModule;
  }

  return result;
}

function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}

function getShaderName(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}

function getApplicationDefines() {
  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let count = 0;
  let sourceText = '';

  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }

    count++;
    const value = defines[define];

    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }

  if (count === 0) {
    sourceText += '\n';
  }

  return sourceText;
}

function getHookFunctions(shaderStage, hookInjections) {
  let result = '';
  const hookFunctions = HOOK_FUNCTIONS[shaderStage];

  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");

    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }

    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);

      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }

    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }

    result += '}\n';
  }

  return result;
}
//# sourceMappingURL=assemble-shaders.js.map