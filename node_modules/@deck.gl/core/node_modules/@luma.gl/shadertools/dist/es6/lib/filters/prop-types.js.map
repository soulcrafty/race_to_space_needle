{"version":3,"sources":["../../../../src/lib/filters/prop-types.js"],"names":["TYPE_DEFINITIONS","boolean","validate","value","propType","number","validateType","Number","isFinite","max","min","parsePropTypes","propDefs","propTypes","defaultProps","propName","propDef","Object","entries","parsePropType","name","getTypeOf","normalizePropType","parsePropDefinition","guessArrayType","type","guessNumberType","array","test","length","assign","typeDefinition","typeValidator","isKnownProp","Math","Array","isArray","ArrayBuffer","isView"],"mappings":"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","sourcesContent":["// // import assert from '../../utils'; // TODO\n\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    }\n  },\n  number: {\n    validateType(value, propType) {\n      return (\n        'value' in propType &&\n        (!('max' in propType) || Number.isFinite(propType.max)) &&\n        (!('min' in propType) || Number.isFinite(propType.min))\n      );\n    },\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const propType = parsePropType(propName, propDef);\n    propTypes[propName] = propType;\n    defaultProps[propName] = propType.value;\n  }\n  return {propTypes, defaultProps};\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      propDef = normalizePropType(name, propDef);\n      return parsePropDefinition(propDef);\n\n    case 'array':\n      return guessArrayType(name, propDef);\n\n    case 'boolean':\n      return {name, type: 'boolean', value: propDef};\n\n    case 'number':\n      return guessNumberType(name, propDef);\n\n    case 'function':\n      return {name, type: 'function', value: propDef};\n    // return guessFunctionType(name, propDef);\n\n    default:\n      return {name, type: 'unknown', value: propDef};\n  }\n}\n\nfunction guessArrayType(name, array) {\n  if (/color/i.test(name) && (array.length === 3 || array.length === 4)) {\n    return {name, type: 'color', value: array};\n  }\n  return {name, type: 'array', value: array};\n}\n\nfunction normalizePropType(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {name, type: 'object', value: propDef};\n    }\n    return Object.assign({name, type: getTypeOf(propDef.value)}, propDef);\n  }\n  return Object.assign({name}, propDef);\n}\n\nfunction parsePropDefinition(propDef) {\n  const {type} = propDef;\n  const typeDefinition = TYPE_DEFINITIONS[type] || {};\n  const {typeValidator} = typeDefinition;\n  if (typeValidator) {\n    // assert(typeValidator(propDef), 'Illegal prop type');\n  }\n\n  return propDef;\n}\n\nfunction guessNumberType(name, value) {\n  const isKnownProp =\n    /radius|scale|width|height|pixel|size|miter/i.test(name) && /^((?!scale).)*$/.test(name);\n  const max = isKnownProp ? 100 : 1;\n  const min = 0;\n  return {\n    name,\n    type: 'number',\n    max: Math.max(value, max),\n    min: Math.min(value, min),\n    value\n  };\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n"],"file":"prop-types.js"}