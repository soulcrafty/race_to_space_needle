import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import Texture from './texture';
import { assertWebGLContext } from '../webgl-utils';
import { log } from '../utils';
const FACES = [34069, 34070, 34071, 34072, 34073, 34074];
export default class TextureCube extends Texture {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    assertWebGLContext(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }

  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;

      if (mipmaps) {
        this.generateMipmap(props);
      }

      this.setParameters(parameters);
    });
  }

  subImage(_ref) {
    let {
      face,
      data,
      x = 0,
      y = 0,
      mipmapLevel = 0
    } = _ref;
    return this._subImage({
      target: face,
      data,
      x,
      y,
      mipmapLevel
    });
  }

  setCubeMapImageData(_ref2) {
    var _this = this;

    return _asyncToGenerator(function* () {
      let {
        width,
        height,
        pixels,
        data,
        border = 0,
        format = 6408,
        type = 5121
      } = _ref2;
      const {
        gl
      } = _this;
      const imageDataMap = pixels || data;
      const resolvedFaces = yield Promise.all(FACES.map(face => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));

      _this.bind();

      FACES.forEach((face, index) => {
        if (resolvedFaces[index].length > 1 && _this.opts.mipmaps !== false) {
          log.warn("".concat(_this.id, " has mipmap and multiple LODs."))();
        }

        resolvedFaces[index].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });

      _this.unbind();
    })();
  }

  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data;
    this.bind();

    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }

    return this;
  }

}
TextureCube.FACES = FACES;
//# sourceMappingURL=texture-cube.js.map